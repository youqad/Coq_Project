<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>exos_introductifs</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library exos_introductifs</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h2 class="section">Coq : Une petite introduction</h2>

<div class="paragraph"> </div>

 Il est possible de générer un fichier HTML à partir de celui-ci. Cependant je vous conseille de lire ce fichier dans votre éditeur de texte afin de pouvoir directement interagir avec Coq. L'objet de ce TP est de vous présenter les fondements du logiciel Coq et qu'à la fin, vous soyez à l'aise pour faire des preuves assez simples. 
<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">I : Introduction</h1>

<div class="paragraph"> </div>

<a name="lab3"></a><h2 class="section">1. 3 langages différents</h2>

<div class="paragraph"> </div>

 L'outil Coq regroupe trois langages distincts :
<ul class="doclist">
<li> Galina, le langage des termes

</li>
<li> Le vernaculaire, le langage des commandes

</li>
<li> Ltac, le langage des <i>tactiques</i>


</li>
</ul>
Au sein d'un développement Coq, on manipule ces trois langages un peu en même temps. Pour prouver un développement, Coq se base sur un <i>type checker</i>. Toute la confiance de nos développements en Coq repose sur ce type checker. Cependant ce type checker n'existe que pour le langage Galina. Ce qui veut dire que tout développement Coq se ramène <i>in fine</i> à type checker des termes dans le langage Galina. Le vernaculaire et Ltac sont des <i>méta-langages</i> qui permettent de nous faciliter la vie et d'interagir avec l'outil.

<div class="paragraph"> </div>

Coq se base sur l'isomorphisme de Curry-Howard aussi appelé <i>propositions as types principle</i>. C'est à dire que prouver un énoncé A (écrit en Galina) revient à écrire un programme f dont le type est A.
En général, un tel terme f peut-être gros et pénible à écrire. Pour pallier à ce problème, on utilise un langage de tactiques. En combinant des tactiques, ce dernier nous permet de générer un terme f qui aura (on l'espère) le bon type.

<div class="paragraph"> </div>

La logique derrière Coq s'appelle le calcul des constructions inductifs. Cependant, dans le cadre de ce cours, on ne s'intéressera pas vraiment à la logique sous-jacente de Coq. On va seulement utiliser Coq comme un outil pour nous permettre de prouver nos programmes.

<div class="paragraph"> </div>

Enfin, le vernaculaire est un langage de commandes. C'est par exemple en utilisant le vernaculaire que l'on va indiquer à Coq qu'on est en train de définir un théorème, un lemme, ou bien on est entrain de créer une fonction. On intéragira toujours avec Coq grâce au vernaculaire. Voilà pour le point théorique, passons maintenant à la pratique.
 
<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">2. Types en Coq</h2>

<div class="paragraph"> </div>

 Objectif :
<ul class="doclist">
<li> introduction aux commandes Check, About Print.

</li>
<li> introduction aux entiers en Coq

</li>
</ul>
 
<div class="paragraph"> </div>

 La commande Check (faites attention à la casse) prend en entrée un terme et s'il est bien typé, affiche son type. Toute commande en Coq se termine par un point. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> 3.<br/>

<br/>
</div>

<div class="doc">
Le type de 3 est nat. En Galina, les types sont aussi des termes (une conséquence des types dépendants 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
Set est ce qu'on appelle une <i>sorte</i>. Une <i>sorte</i> est un type dont les éléments sont eux-mêmes des types. Par exemple, le type bool est aussi dans Set 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Il existe plusieurs sortes en Coq. On peut distinguer trois sortes en Coq : Set, Prop et Type. La sorte Prop est le type des propositions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">x</span> = <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
Il se trouve que les sortes ont eux-même un type 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Set</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
On peut résumer cette hiérarchie de types par le schéma suivant (merci Lucca) :
<pre>
                 Type
               /      \
            Set       Prop
           /  |      /    \
        nat  bool  True  ((1=0) \/ False)
       / |   /  \
      1  0  true false
</pre>
 
<div class="paragraph"> </div>

 Afin de vous éviter des détails logiques, Coq vous ment un peu dans son affichage. En général, c'est pour notre bien, mais parfois cela peut-être gênant. Ainsi, si Type n'est pas vraiment une sorte, c'est Type 0 qui en est une. De plus, le type de Type 0 c'est Type 1. Pour s'en apercevoir on peut utiliser le vernaculaire 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Printing Universes</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Set</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Unset Printing Universes</span>.<br/>

<br/>
</div>

<div class="doc">
Au lieu d'utiliser la commande Check pour les types, il est aussi possible d'utiliser la commande About qui donne un peu plus d'informations 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">About</span> <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
Cependant, cette dernière ne fonctionne pas pour les sortes 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
On peut aussi vouloir afficher la définition d'un type ou bien d'une fonction. Pour cela on utilise la commande Print 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">plus</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">Nat.add</span>.<br/>

<br/>
</div>

<div class="doc">
En conclusion :
<ul class="doclist">
<li> En Coq n'importe quel terme a un type

</li>
<li> On distingue les types des données comme nat, bool, avec le type des propositions (1 = 2, True)

</li>
<li> Set est la sorte qui contient les types pour les données, tandis que Prop est la sorte des propositions

</li>
<li> Pour connaître le type d'un terme on utilise Check ou About (cette dernière est préférable en général)

</li>
<li> Pour connaître la définition d'un type, d'une fonction on utilise la commande Print

</li>
</ul>
 
<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">3. Librairies et notations</h2>

<div class="paragraph"> </div>

 Objectif :
<ul class="doclist">
<li> Introduction au système de module de Coq et la gestion des noms

</li>
<li> Introduction aux commandes Require Import et Locate

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat</span>.<br/>
</div>

<div class="doc">
Quand tout à l'heure, on a exécuté la commande Print nat, on a vu que ce dernier avait une définition (on verra ce que veut dire le mot-clé inductive plus tard) :
<pre>
Inductive nat : Set :=  O : nat | S : nat -&gt; nat
</pre>

<div class="paragraph"> </div>

Donc on peut en conclure que que les entiers ne sont pas primitifs en Coq. Heureusement, le logiciel est bien fait et nous permet d'écrire nos entiers en base 10 comme on a l'habitude, mais derrière le terme est bien unaire. On peut le vérifier ainsi :
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Printing All</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">S</span> 0).<br/>

<br/>
<span class="id" title="keyword">Check</span> (1 = <span class="id" title="var">S</span> 0).<br/>

<br/>
<span class="id" title="keyword">Unset Printing All</span>.<br/>

<br/>
</div>

<div class="doc">
Par défaut, Coq vient avec toute une librairie. C'est le cas des connecteurs logiques entre autres. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">or</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">and</span>.<br/>

<br/>
</div>

<div class="doc">
Pour importer d'autres librairies en Coq, on utilise la commande Require Import 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>

<br/>
</div>

<div class="doc">
C'est un peu l'équivalence de la commande open en OCaml. Cependant, vous vous apercevrez par la suite qu'il peut très rapidement y avoir des conflits de noms. Afin qu'il soit plus facile de lire des définitions ou bien des formules mathématiques, Coq utilise un système de notation. Ainsi on écrit en général True /\ True plutôt que and True True : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">True</span> ∨ <span class="id" title="var">True</span>).<br/>

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">or</span> <span class="id" title="var">True</span> <span class="id" title="var">True</span>).<br/>

<br/>
</div>

<div class="doc">
Pour voir à quel symbole est associé une notation, on utilise la commande Locate qui prend en argument une chaîne de caractères. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "\/".<br/>

<br/>
</div>

<div class="doc">
La commande Locate nous indique aussi le scoping de la notation. En effet, la définition de plus sur les entiers est différente de celle sur les réels. Pourtant, on voudrait garder la même notation. Le scoping permet donc de lever cette ambiguïté. Par exemple pour la notation + il y a plusieurs définitions 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "+".<br/>

<br/>
</div>

<div class="doc">
Pour préciser le scoping d'un terme t, il faut préciser le scope en ajoutant un scope 
<div class="paragraph"> </div>

 Conclusion :
<ul class="doclist">
<li> Require Import fonctionne comme le Open d'OCaml

</li>
<li> Les librairies introduisent de nombreuses notations.

</li>
<li> Pour connaître la définition d'une notation, on utiliser la commande Locate

</li>
<li> La même notation peut-être rattachée à plusieurs définitions

</li>
<li> Coq résoud ces conflits en utilisant la notion de scoping (parfois appelé namespace)

</li>
</ul>
 
<div class="paragraph"> </div>

<a name="lab6"></a><h2 class="section">3. Des preuves simples</h2>

<div class="paragraph"> </div>

 Objectif :
<ul class="doclist">
<li> Introduction au mode de preuve interactif

</li>
<li> Introduction aux tactiques : intro(s), apply, assumption, easy, reflexivity, exact

</li>
</ul>
 
<div class="paragraph"> </div>

 Passés ces détails techniques de Coq, intéressons-nous au monde de la preuve en Coq. Il existe deux façons de faire des preuves en Coq, soit on donne le terme et le type directement, soit on utilise le mode intéractif pour construire la preuve à l'aide de tactiques. Le mot-clé Definition permet d'associer un nom à un terme t dont le type est A. C'est une façon de faire pour construire une preuve en Coq : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">trivial0</span> : 1 = 1 := <span class="id" title="var">eq_refl</span>.<br/>

<br/>
</div>

<div class="doc">
Coq nous indique qu'il est content avec le message "trivial is defined". Ici on a donc trivial qui est un programme dont le type est 1 = 1. On a donc construit un terme de type 1 = 1, autrement dit on vient de prouver 1 = 1. Pour cela, on a utilisé eq_refl. On reviendra sur eq_refl un peu plus tard, c'était juste pour vous donner un exemple de la construction d'un terme. De façon général, derrière le symbole ":" on met un type, ici 1 = 1, et après := on met une définition ici eq_refl. Pour le mode interactif, on utilise en général d'autres commandes comme Lemma ou Theorem. Pour dire à Coq que l'on commence une preuve, ces commandes sont suivies de la commande Proof 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial1</span> : 1 = 1.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">
On s'aperçoit alors que Coq change de mode. C'est le mode interactif qui permet de construire des termes. En dessous de la barre se trouve le <i>goal</i>, tandis qu'au dessus se trouve <i>le contexte</i> (ici il est vide). Maintenant, Coq attend une tactique. Coq vient par défaut avec de nombreuses tactiques et il est possible d'en définir soi-même (même si on ne le fera pas durant ce cours). Pour des cas aussi simples il existe plusieurs tactiques. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">auto</span>.<br/>

<br/>
</div>

<div class="doc">
Ici, Coq nous indique qu'il a résolu les buts et donc que la preuve est finie. auto est une tactique un peu magique qui résoud de nombreux goals. Cependant, dans le cadre de ce cours, je vous interdis de l'utiliser. Cette commande est un peu magique et on ne comprend pas forcément comment elle fonctionne. Il y a toujours une façon de se passer d'auto. Dans un but pédagogique, on va restart la preuve pour voir d'autres tactiques. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
La tactique reflexivity permet de résoudre des buts de la forme x = x, ce qui est notre cas. Dans Emacs ou bien CoqIde, cette tectique est coloriée en rouge. Cela veut dire qu'elle résoud un but et que si elle n'y arrive pas elle échoue. Par exemple tentez la tactique suivante (en enlevant la commande Fail) 
<div class="paragraph"> </div>

 il existe une autre tactique un peu plus général -- easy -- qui permet aussi de résoudre ce but 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>

<br/>
</div>

<div class="doc">
Pour indiquer à Coq que l'on a fini une preuve, on utilise la commande Qed. 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pour l'instant on a vu comment résoudre un but de la forme x = x, mais on ne va pas aller très loin ainsi. On va voir comment résoudre des propositions contenant des implications et des forall. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial2</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span>:<span class="id" title="var">nat</span>), <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">
pour prouver un but contenant un forall en tête, on utilise la tactique intro. On peut donner un identifiant au paramètre introduit 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
On s'aperçoit que la tactique introduit a réussi car elle nous a ajouté x dans le contexte. On peut maintenant conclure la preuve. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>

<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Regardons avec l'implication maintenant. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial3</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span>:<span class="id" title="keyword">Prop</span>), <span class="id" title="var">P</span> → <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
Pour introduire la flèche, on peut réutiliser la même tactique intro 
<div class="paragraph"> </div>

 A noter qu'il est possible de combiner de faire plusieurs introductions en une seule fois avec la tactique intros. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Maintenant on se retrouve à vouloir donner un terme de type P. Heureusement on a un dans notre contexte, c'est H. On peut utiliser la tactique assumption pour dire à Coq d'utiliser H sans avoir besoin de mentionner l'hypothèse. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>

<br/>
</div>

<div class="doc">
On peut aussi utiliser la tactique exact pour préciser spécialement l'hypothèse à utiliser 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A ce stade, pour souligner l'utilisation de Curry-Howard, il peut-être intéressant de regarder les termes que l'on a définis. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">trivial0</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">trivial1</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">trivial2</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">trivial3</span>.<br/>

<br/>
</div>

<div class="doc">
On remarque en regardant le type de trivial3, que l'introduction de l'implication et du pour tout se traduisent tous les deux par une "abstraction", c'est à dire en construisant une fonction. La différence se fait seulement au niveau du type. En fait, dans la théorie de Coq (et de façon plus générale quand on a affaire aux types dépendants, l'implication est un cas particulier du pour tout). 
<div class="paragraph"> </div>

 Enfin, on va voir l'utilisation d'une dernière tactique : apply qui va nous permettre de prouver le théorème suivant : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial4</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span>:<span class="id" title="keyword">Prop</span>), (<span class="id" title="var">A</span> → <span class="id" title="var">B</span>) → <span class="id" title="var">A</span> → <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H</span> <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
Comment on construit un terme de type B ? Pas le choix il faut utiliser H ! Cependant, il y a deux façons de le faire : en forward reasonning ou en backward reasoning. En forward reasoning on voudra faire nos manipulations dans le contexte et fabriquer un terme de type B. Pour se faire on peut utiliser la règle du modus ponens et dire si j'ai du A et du A -&gt; B, alors je peux construire du B. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
Coq nous dit alors qu'à partir de a : A je peux construire un type b : B. Dans notre cas, il fait le remplacement directement au sein du terme a. A l'inverse, en backward reasoning, on va appliquer H au goal directement 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Cette fois, Coq nous demande de lui donner un terme de type A, que l'on a directement depuis le contexte, on peut donc conclure 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Avec ce petit ensemble de tactiques, vous pouvez vous exercez à prouver les formules suivantes. Remplacez le Admitted par votre preuve 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example0</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span>, <span class="id" title="var">A</span> → <span class="id" title="var">A</span> → <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>, (<span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) → <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">H</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> ; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example3</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> (<span class="id" title="var">H</span>:<span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) (<span class="id" title="var">HA</span>:<span class="id" title="var">A</span>) (<span class="id" title="var">HB</span>:<span class="id" title="var">B</span>), <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">H</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> ; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, (<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span>, <span class="id" title="var">m</span> = 0) → <span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example5</span> : (<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>, <span class="id" title="var">P</span>) → <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conclusion :
<ul class="doclist">
<li> Le mode de preuve interactif permet de construire un terme de preuve pas à pas

</li>
<li> On construit un terme de preuve en combinant un ensemble de tactiques

</li>
<li> La tactique intros permet d'introduire dans le contexte la prémisse d'une implication mais aussi la variable d'un forall

</li>
<li> Une tactique peut échouer si on ne l'applique pas correctement

</li>
<li> Les tactiques en rouge sont des tactiques qui résolvent à coup sûr un goal ou bien échouent

</li>
<li> Pour prouver un goal B à l'aide d'une hypothèse A -&gt; B, on utilise apply

</li>
<li> Il existe plusieurs façons de construire des preuves en Coq, certaines sont plus intuitives que d'autres

</li>
</ul>
 
<div class="paragraph"> </div>

<a name="lab7"></a><h2 class="section">4. Raisonner avec l'égalité</h2>

<div class="paragraph"> </div>

 Objectifs :
<ul class="doclist">
<li> Introduction à la notion de calcul en Coq

</li>
<li> Introduction à la commande Eval ... in ...

</li>
<li> Introduction aux tactiques simpl,rewrite, subst, clear et pose proof

</li>
<li> Introduction aux tacticielles now ...

</li>
<li> Introduction à la recherche de théorèmes en Coq 
</li>
</ul>

<div class="paragraph"> </div>

 L'égalité à un statut très particulier en Coq. En particulier ce n'est pas la même que l'égalité d'Ocaml : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">equality</span> : 2 + 2 = 4.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
En Coq, il existe 4 notions différentes de calcul. La notion de calcul est profondément ancrée dans Coq. C'est ce qui fait que l'égalité de Coq est plus <i>puissante</i> que celle d'OCaml, car en Coq l'égalité va utiliser la notion de calcul intégrée en Coq. Ceci est possible car Coq n'est pas Turing-Complet : tout calcul termine ! Comme le cacul termine toujours en Coq, pour tester l'égalité entre deux termes a et b, Coq va chercher à <i>réduire</i> (en calculant) un maximum a et b et vérifier que leurs <i>formes normales</i> sont structurellement égales. Comprendre comment un terme va se réduire n'est pas évident au premier abord et demande de la pratique. 
<div class="paragraph"> </div>

 En général, on ne fait pas de distinction entre les différentes notions de calcul. Pour demander à Coq de calculer, on peut utiliser la commande Eval compute in 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (2 + 2).<br/>

<br/>
</div>

<div class="doc">
compute est une <i>stratégie de réduction</i> qui englobe les 4 notions de calculs. Il existe cependant d'autres stratégies de calcul qui pour nous auront peu d'intérêt. 
<div class="paragraph"> </div>

 Voici un exemple simple pour vous montrer un des pièges de l'égalité en Coq : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial5</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trivial6</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
0 + n se réduit naturellement vers n, mais ce n'est pas le cas de n + 0. Cela dépend de la façon dont on a définit la fonction plus, on verra ça dans la suite de cette introduction. 
<div class="paragraph"> </div>

 On va voir maintenant comment utiliser des égalités en sein de nos preuves. Par exemple si j'ai dans mon contexte une égalité A = B et que mon goal c'est A, je voudrais pouvoir l'utiliser pour réécrire mon goal en B 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial7</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">R</span>.<br/>

<br/>
</div>

<div class="doc">
pour réécrire n en m, on utilise la tactique rewrite 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">R</span>.<br/>

<br/>
</div>

<div class="doc">
cependant, on aurait pu vouloir réécrire m en n. Cela se fait aussi avec rewrite 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">R</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
par défaut rewrite écrit de gauche à droite. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial8</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">n</span> + <span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">m</span> + <span class="id" title="var">S</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">R</span>.<br/>

<br/>
</div>

<div class="doc">
now est une tacticielle : elle prend en paramètre une autre tactique. On peut voir now H comme un raccourci pour H. easy. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">R</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
il peut arriver à un moment dans l'élaboration d'une preuve d'avoir plusieurs égalités de la forme :
x1 = t1, x2 = t2, ... , xn = tn . Pour éviter d'avoir à écrire n fois rewrite et surtout de nommer à chaque fois les hypothèses, on peut utiliser la tactique subst qui va faire ça à notre place. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial9</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> <span class="id" title="var">n3</span> <span class="id" title="var">n4</span>, <span class="id" title="var">n1</span> = <span class="id" title="var">n2</span> + <span class="id" title="var">n2</span> → <span class="id" title="var">n2</span> = <span class="id" title="var">n3</span> + <span class="id" title="var">n3</span> → <span class="id" title="var">n3</span> = <span class="id" title="var">n4</span> + <span class="id" title="var">n4</span> → <span class="id" title="var">n1</span> = 8 × <span class="id" title="var">n4</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> <span class="id" title="var">n3</span> <span class="id" title="var">n4</span> <span class="id" title="var">R1</span> <span class="id" title="var">R2</span> <span class="id" title="var">R3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>

<br/>
</div>

<div class="doc">
A noter que subst fonctionne si l'un des deux membres de l'égalité est une variable. 
<div class="paragraph"> </div>

 Cependant, il n'est pas possible de conclure directement car Coq n'arrive pas à voir que les deux membres sont égaux. Cela peut se voir en réduisant le membre droit à l'aide de la tactique simple. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
</div>

<div class="doc">
simpl est une tactique très pratique qui comme son nom l'indique permet de simplifier des buts. Comment on va dire à Coq qu'il est possible de résoudre ce but ? On va utiliser des lemmes. Heureusement ils ont déjà été prouvés pour nous. Mais comment trouver le nom de ces lemmes ? Pour cela on va utiliser la commande Search. Cette commande prend ou bien un nom en paramètre, ou bien un <i>pattern</i>.  
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">SearchAbout</span> "plus".<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Search</span> "add".<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Search</span> (<span class="id" title="var">_</span> + 0).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Search</span> (<span class="id" title="var">_</span> (<span class="id" title="var">_</span> + <span class="id" title="var">_</span>) = (<span class="id" title="var">_</span> + <span class="id" title="var">_</span>) + <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
les deux lemmes dont on a besoin sont donc plus_n_O et PeanoNat.Nat.add_assoc . Il est possible de les inclure dans le contexte en utilisant la commande pose proof. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">plus_n_O</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">PeanoNat.Nat.add_assoc</span>.<br/>

<br/>
</div>

<div class="doc">
Quand il y a un forall dans une hypothèse, alors de deux choses l'une :
<ul class="doclist">
<li> soit Coq peut deviner la variable par lequel il faut instancier le terme

</li>
<li> sinon il faut préciser la variable à instancier.

</li>
</ul>

<div class="paragraph"> </div>

      Ici, Coq est assez malin pour trouver la variable tout seul.
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Le premier lemme est maintenant inutile. On peut le supprimer du contexte avec la tactique clear 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Maintenant il va falloir appliquer un certain nombre de fois l'associativité de plus. Cependant, le lemme peut s'appliquer un peu n'importe où. Comment décider où l'appliquer ? On peut préciser certains termes : 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<span class="id" title="var">H0</span> <span class="id" title="var">_</span> <span class="id" title="var">n4</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
Le plus simple ici consiste tout de même à l'appliquer autant de fois que nécessaire. Cela peut se faire à l'aide de la tactique repeat. repeat est une autre tacticielle qui applique autant de fois que possible une tactique. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H0</span>.<br/>

<br/>
</div>

<div class="doc">
Il est aussi possible d'utiliser des procédures de décision en Coq qui font le travail à notre place. On peut par exemple utiliser omega 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>. <span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Conclusion :
<ul class="doclist">
<li> On a vu comment manipuler des hypothèses de la forme a = b avec rewrite ou subst

</li>
<li> On a vu nos deux premières tacticielles :
<ul class="doclist">
<li> now  qui permet de conclure un goal à l'aide d'une tactique

</li>
<li> repeat qui permet de répeter une tactique jusqu'à ce qu'elle échoue

</li>
</ul>

</li>
<li> Souvent, on aura besoin des lemmes de la librairie standard. Pour trouver le nom du lemme à utiliser, on peut utiliser la commande Search.

</li>
<li> On a vu une nouvelle tactique pose proof qui permet d'introduire un lemme dans le contexte.

</li>
<li> On a pu noter que certains goals trivials peuvent être contraignants à prouver.

</li>
<li> Pour pallier à ce souci, on peut utiliser des procédures de décision.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab8"></a><h2 class="section">5. Les types inductifs</h2>

<div class="paragraph"> </div>

 Objectif :
<ul class="doclist">
<li> Présentation des types inductifs et du pattern matching

</li>
<li> Introduction de la tactique destruct, induction et inversion

</li>
</ul>

<div class="paragraph"> </div>

 Il y a plusieurs façons d'aborder les types inductifs. Pour les gens venant de la programmation fonctionnelle, il peut être intéressant de voir les types inductifs comme une généralisation des types algébriques. L'exemple canonique de type inductif ce sont les entiers naturels. En Ocaml, on pourrait écrire le type suivant :

<div class="paragraph"> </div>

type nat = O | S of nat

<div class="paragraph"> </div>

l'équivalent en Coq est le type inductif suivant : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
 Contrairement à OCaml, on peut appliquer les constructeurs partiellement : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">S</span>.<br/>

<br/>
</div>

<div class="doc">
Les types inductifs de Coq viennent aussi avec un principe d'élimination. Pour les entiers naturels cela se traduit tout simplement par le principe d'induction que l'on connaît bien. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span>.<br/>

<br/>
</div>

<div class="doc">
Ce principe d'induction est décliné en trois versions en fonction de la sorte d'arrivée du prédicat. Dans notre cas, seul nat_ind et nat_rec nous intéressent. Le premier permet de faire une raisonnement inductif, tandis que le second permet de créer des fonctions récursivement. Cependant en général, Coq manipule ces fonctions de façon transparente et on ne manipulera pas ces termes directement. 
<div class="paragraph"> </div>

 Voici par exemple comment définir plus en Coq. Ici on introduit la commande Fixpoint qui permet d'écrire des fonctions <i>structurellement</i> récursives en Coq. Si Coq ne trouve pas d'argument structurellement décroissant, la définition sera rejetée. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">k</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">k</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
On peut matcher sur les types inductifs comme on a l'habitude de le faire en OCaml. En Coq, une des façons de calculer provient directement du pattern-matching : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">plus</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)) <span class="id" title="var">O</span>).<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">plus</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>) (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)).<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">Nat.add</span>.<br/>

<br/>
</div>

<div class="doc">
Quand on fait un match n with et que n est une valeur, alors Coq sait automatiquement dans quelle branche on est et donc réduire le terme de départ n. C'est ce qui explique la <i>bizarrerie</i> que l'on a observée tout à l'heure avec n + 0 = n . n n'étant pas une valeur, Coq ne sait pas s'il doit passer dans la première branche ou bien dans la seconde. Donc n + 0 est déjà en <i>forme_normale</i> . Cependant, il est possible de <i>prouver</i> que n + 0 = n. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_n_0</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Afin d'aider Coq, on voudrait distinguer 2 cas. Soit n = 0, soit n = S n'. Pour cela, on peut utiliser la tactique destruct 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
A noter que Coq génère deux goals, un pour chaque cas. Automatiquement Coq focus un goal. Il est possible d'en changer à l'aide de la commande Focus n. Ici, pour le cas où n = 0, c'est simple. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
Dans le cas inductif, on peut simplifier l'expression 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
</div>

<div class="doc">
et là, on est à nouveau bloqué ! Pour s'en sortir, il va falloir faire une preuve par induction. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
</div>

<div class="doc">
une preuve par induction se fait avec la tactique induction 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
on recommence... 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
</div>

<div class="doc">
Cette fois, on peut utiliser notre hypothèse d'induction pour réécrire notre but 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
induction est malin et trouve tout seul sur quelle propriété il faut appliquer le principe d'induction. En général ce sera toujours le cas, mais il peut y avoir des différences. C'est ce que l'on va voir sur l'exemple suivant. 
<div class="paragraph"> </div>

 On va chercher à prouver la commutativité de l'addition 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">S_plus_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> + <span class="id" title="var">Datatypes.S</span> <span class="id" title="var">m</span> = <span class="id" title="var">Datatypes.S</span> (<span class="id" title="var">n</span>+<span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>

<br/>
</div>

<div class="doc">
l'hypothèse d'induction que l'on a est : n + m = m + n . Autrement dit, m est fixé. Alors même si dans notre cas, cela ne pose pas de soucis, dans d'autres cas, cette hypothèse d'induction ne sera pas assez générale. Coq n'est pas assez malin pour généraliser tout ce qu'il peut généraliser. Donc faites attention quand vous souhaitez prouver des lemmes par induction à ce qu'il y a dans votre contexte. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>

<br/>
</div>

<div class="doc">
vous voyez la différence ? Alors maintenant se pose le problème qu'il est possible que vous ayez introduit une variable dans le contexte et qu'à nouveau vous souhaitiez la réintroduire dans la goal pour que Coq puisse généraliser dessus. Dans ce cas, vous pouvez utiliser ou bien la tactique revert, ou bien la tactique generalize dependent. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cut</span> (<span class="id" title="var">m</span> + <span class="id" title="var">Datatypes.S</span> <span class="id" title="var">n</span> = <span class="id" title="var">Datatypes.S</span> (<span class="id" title="var">m</span>+<span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">S_plus_comm</span>.<br/>

<br/>
</div>

<div class="doc">
et là on est à nouveau bloqué ! 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Exercice : trouvez le lemme manquant et prouvez la commutativité de l'addition 
<div class="paragraph"> </div>

 Exercices : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zero_plus</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">p</span>, <span class="id" title="var">p</span> + 0 = <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span>; <span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span>, <span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">o</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">o</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">o</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">zero_plus</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">S_plus_comm</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">zero_plus</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">S_plus_comm</span>; <span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHo</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Locate</span> "*".<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">Init.Nat.mul</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">times_right</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>, <span class="id" title="var">p</span> × <span class="id" title="var">Datatypes.S</span> <span class="id" title="var">q</span> = <span class="id" title="var">p</span> + <span class="id" title="var">p</span>×<span class="id" title="var">q</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">times_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> × <span class="id" title="var">m</span> = <span class="id" title="var">m</span> × <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">times_right</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">times_zero</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span>*0 = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_distr_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span>, <span class="id" title="var">n</span> × (<span class="id" title="var">m</span> + <span class="id" title="var">o</span>) = (<span class="id" title="var">n</span> × <span class="id" title="var">m</span>) + (<span class="id" title="var">n</span>×<span class="id" title="var">o</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>×<span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">times_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span>, <span class="id" title="var">n</span> × (<span class="id" title="var">m</span> × <span class="id" title="var">o</span>) = (<span class="id" title="var">n</span> × <span class="id" title="var">m</span>) × <span class="id" title="var">o</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">o</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">times_zero</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">times_right</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_distr_l</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHo</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_distr_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span>, (<span class="id" title="var">m</span> + <span class="id" title="var">o</span>) × <span class="id" title="var">n</span> = (<span class="id" title="var">m</span> × <span class="id" title="var">n</span>) + (<span class="id" title="var">o</span>×<span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">times_zero</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">times_right</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> (<span class="id" title="var">o</span>) (<span class="id" title="var">o</span>×<span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">_</span> <span class="id" title="var">o</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_assoc</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Les listes existent aussi en Coq 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">list</span>.<br/>

<br/>
</div>

<div class="doc">
Les listes sont paramètrées par un type : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">list</span> <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">list</span> <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Comme pour Ocaml, la définition d'une liste se fait de façon inductive :
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">list</span>.<br/>

<br/>
</div>

<div class="doc">
Exercice : Définissez une fonction append qui concaténe deux listes 
<div class="paragraph"> </div>

 Exercice : Définissez une fonction length qui donne la longueur d'une liste 
<div class="paragraph"> </div>

 Exercice : Prouvez un lemme intéressant entre append et length 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) <span class="id" title="var">acc</span> := <span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <span class="id" title="var">rev</span> <span class="id" title="var">t</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">acc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev_append</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) := <span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ <span class="id" title="var">rev_append</span> <span class="id" title="var">t</span> (<span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">l2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">append</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span> := <span class="id" title="var">rev_append</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span> <span class="id" title="var">nil</span>) <span class="id" title="var">l'</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> ⇒ 1 + <span class="id" title="var">length</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">append_len</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span> <span class="id" title="var">l'</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>), <span class="id" title="var">length</span> (<span class="id" title="var">append</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span> + <span class="id" title="var">length</span> <span class="id" title="var">l'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cut</span> (<span class="id" title="var">length</span> (<span class="id" title="var">append</span> (<span class="id" title="var">a</span>::<span class="id" title="var">l</span>) <span class="id" title="var">l'</span>) = 1 + <span class="id" title="var">length</span> (<span class="id" title="var">append</span> <span class="id" title="var">l</span> <span class="id" title="var">l'</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cut</span> (<span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>, <span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l1</span> + <span class="id" title="var">length</span> <span class="id" title="var">l2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">append</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cut</span> (<span class="id" title="keyword">∀</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span>, <span class="id" title="var">length</span> (<span class="id" title="var">rev_append</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l3</span> + <span class="id" title="var">length</span> <span class="id" title="var">l4</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H0</span>; <span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">l3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">l4</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHl3</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">l2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHl1</span>; <span class="id" title="var">now</span> <span class="id" title="tactic">simpl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Avant de passer à la suite, il me reste à vous montrer une tactique qui peut s'avérer très utile en Coq : inversion. Supposons que vous souhaitez démontrer le lemme suivant : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">trivial10</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> , <span class="id" title="var">x</span> = 0 → <span class="id" title="var">x</span> + <span class="id" title="var">x</span> = <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Ici on a besoin de faire un raisonnement par cas avec destruct 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
goal trivial 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>

<br/>
</div>

<div class="doc">
ici le goal est évidement faux, mais c'est parce que l'hypothèse H est elle même fausse. C'est à ce moment là que la tactique inversion entre en jeu. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
et pouf magiquement le goal devient résolu. En effet, dès qu'une hypothèse dans le contexte est fausse, on peut prouver n'importe quoi y compris notre but. Cependant, au lieu d'utiliser destruct, on aurait pu directement utiliser inversion. La tactique aurait alors seulement générée un sous-but : 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
de façon générale, inversion est une bonne tactique pour détruire un type inductif dans un contexte. Contrairement à destruct, il arrive à deviner les cas possibles des cas impossibles 
<div class="paragraph"> </div>

 Conclusion :
<ul class="doclist">
<li> On a vu comment déclarer des types inductifs simples.

</li>
<li> On a vu qu'il est possible de matcher sur des types inductifs

</li>
<li> Coq génère pour nous automatiquement des lemmes d'inductions sur ces types inductifs ce qui nous permet de créer des fonctions récursives et de faire des preuves par induction.

</li>
<li> Il faut faire attention à l'utilisation de la tactique induction de sorte à récupérer la bonne hypothèse d'induction

</li>
<li> inversion est une bonne tactique pour détruire des hypothèses sous-forme inductive dans un contexte

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab9"></a><h2 class="section">5. La logique de Coq</h2>

<div class="paragraph"> </div>

 Objectifs :
<ul class="doclist">
<li> Voir comment la logique de Coq est définie

</li>
<li> introduction aux tactiques unfold et split

</li>
</ul>
  On a vu deux connecteurs logiques en Coq que sont l'implication et forall (ce sont des connecteurs primitifs de Coq). Les autres connecteurs logiques sont définis par des types inductifs. C'est ce que l'on va voir tout de suite. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "/\".<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">and</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">and</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">conj</span>.<br/>

<br/>
</div>

<div class="doc">
conj est le seul constructeur de and. Maintenant, comment on voudrait pouvoir éliminer un and en projettant. Cela revient par exemple à prouver le lemme suivant : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">proj1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> ∧ <span class="id" title="var">B</span> → <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Pour détruire un and dans une hypothèse, on peut utiliser destruct 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">proofA</span> <span class="id" title="var">proofB</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
On peut aussi prouver le lemme suivant : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">conj_and</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">A</span> ∧ <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
Quand on a un type inductif dans un goal, il est possible de le détruire. Ou bien en utilisant la tactique apply que l'on a déjà vue et en spécifiant le nom du constructeur : 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">conj</span>.<br/>

<br/>
</div>

<div class="doc">
Ici le but est trivial et Coq a déjà tout résolu. Quand seulement un constructeur peut s'appliquer, on peut aussi utiliser la tactique construcor : 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>

<br/>
</div>

<div class="doc">
Enfin, vu que and et est tellement courant, on a crée une tactique juste pour lui : split 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Exercice : Définissez un type inductif pour le or. Prouvez un lemme d'élimination dessus. 
<div class="paragraph"> </div>

 Exercice : Définissez un type inductif pour le "il existe". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">or</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">my_or</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">or_left</span> : <span class="id" title="var">A</span> → <span class="id" title="var">my_or</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">or_right</span> : <span class="id" title="var">B</span> → <span class="id" title="var">my_or</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">elim_my_or</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">my_or</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> → (<span class="id" title="var">A</span> → <span class="id" title="var">C</span>) → (<span class="id" title="var">B</span> → <span class="id" title="var">C</span>) → <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>; <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H1</span>; <span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Locate</span> "exists".<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">ex</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">my_exists</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span> → <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">exists_el</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">A</span> <span class="id" title="var">x</span> → <span class="id" title="var">my_exists</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
Cependant, la définition de ces connecteurs n'est pas unique. Par exemple : 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">my_and</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">z</span>:<span class="id" title="keyword">Prop</span>, (<span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">z</span>) → <span class="id" title="var">z</span>.<br/>

<br/>
</div>

<div class="doc">
Exercice : il est possible de prouver les règles usuelles du et sur ce nouveau constructeur : 
<div class="paragraph"> </div>

 A noter que la tactique unfold permet de dérouler une définition 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">cons_my_and</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">my_and</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">HA</span> <span class="id" title="var">HB</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">my_and</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">my_and_proj1</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">my_and</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> → <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">my_and</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>; <span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">cons_my_and</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">my_and_proj1</span>.<br/>
</div>

<div class="doc">
Exercice : Sans utiliser les types inductifs et seulement à l'aide du pour tout et de l'implication, créez une nouvelle définition my_or avec le comportement souhaité 
<div class="paragraph"> </div>

 Exercice : Dans le même esprit faites pareil avec la négation 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">my_or2</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>:<span class="id" title="keyword">Prop</span>, (<span class="id" title="var">A</span> → <span class="id" title="var">x</span>) → (<span class="id" title="var">B</span> → <span class="id" title="var">x</span>) → <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equiv_or</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>), <span class="id" title="var">A</span> ∨ <span class="id" title="var">B</span> ↔ <span class="id" title="var">my_or2</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">my_or2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>; <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H1</span>; <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">my_or2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">x</span>:=<span class="id" title="var">A</span>∨<span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">left</span>; <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">right</span>; <span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">equiv_or</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">my_not</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">A</span> → <span class="id" title="var">False</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">equiv_not</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>), ¬<span class="id" title="var">A</span> ↔ <span class="id" title="var">my_not</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">easy</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Conclusion :
<ul class="doclist">
<li> On a vu une définition possible des connecteurs logiques dans Coq, c'est celle qui est utilisée dans quasiment tous les développements

</li>
</ul>

<div class="paragraph"> </div>

 Ouch ! On arrive enfin au bout de cette introduction, et je l'espère vous devriez avoir les bases pour commencer. On mettra en pratique ce qu'on a vu lors de la seconde session afin de prouver un algorithme de tri en Coq 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>